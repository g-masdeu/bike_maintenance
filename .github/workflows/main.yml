name: Laravel CI/CD

on:
  push:
    branches: [ "main", "master" ]
  pull_request:
    branches: [ "main", "master" ]

jobs:
  laravel-tests:
    runs-on: ubuntu-latest

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: bike_maintenance
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping --silent"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    env:
      DB_CONNECTION: mysql
      DB_HOST: 127.0.0.1
      DB_PORT: 3306
      DB_DATABASE: bike_maintenance
      DB_USERNAME: root
      DB_PASSWORD: root

    steps:
      - name: â¬‡ï¸ Checkout del cÃ³digo
        uses: actions/checkout@v4

      - name: âš™ï¸ Configurar PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          extensions: imagick, mbstring, pdo_mysql, bcmath, fileinfo, gd, ext-ctype, xml
          coverage: none

      - name: âš™ï¸ Configurar Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: ðŸ“¥ Instalar dependencias de Node
        run: npm ci

      - name: ðŸ—ï¸ Construir assets con Vite
        run: npm run build --if-present

      - name: ðŸ“¦ Instalar dependencias de Composer
        run: composer install --prefer-dist --no-progress

      - name: ðŸ“„ Configurar entorno de testing (.env)
        run: cp .env.example .env

      - name: ðŸ”‘ Generar APP_KEY
        run: php artisan key:generate

      - name: ðŸ”„ Ejecutar Migraciones
        run: php artisan migrate --force

      - name: ðŸ§ª Ejecutar pruebas
        run: php artisan test --ci

  deploy:
    runs-on: self-hosted
    needs: laravel-tests
    if: github.ref == 'refs/heads/main'

    steps:
      # Paso 1: Detener contenedores por si estuvieran bloqueando archivos
      - name: ðŸ³ Detener contenedores anteriores
        run: docker compose down -v || true

      # Paso 2: Limpiar y restaurar la propiedad
      - name: ðŸ§¹ Limpiar directorio y restaurar propiedad
        run: |
          sudo chown -R $(whoami):$(whoami) ${{ github.workspace }} || true
          rm -rf ${{ github.workspace }}/* || true

      # Paso 3: Descargar el cÃ³digo sin limpieza automÃ¡tica
      - name: â¬‡ï¸ Descargar cÃ³digo
        uses: actions/checkout@v4
        with:
          clean: false

      - name: ðŸš€ Desplegar con Docker
        env:
          # Variables de la aplicaciÃ³n para el script
          APP_KEY: ${{ secrets.APP_KEY }}
          APP_URL: ${{ secrets.APP_URL }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
        run: |
          # 1. EXPORTAR SECRETS DE BASE DE DATOS PARA SU USO EN EL SHELL (cat)
          # Esto resuelve el error de ${DB_USERNAME}
          export DB_PORT="${{ secrets.DB_PORT }}"
          export DB_DATABASE="${{ secrets.DB_DATABASE }}"
          export DB_USERNAME="${{ secrets.DB_USERNAME }}"
          export DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
          
          # Crear archivo nginx/default.conf
          mkdir -p nginx
          cat > nginx/default.conf <<'EOL'
          server {
              listen 80;
              server_name _;
              
              root /var/www/html/public;
              index index.php;

              location / {
                  try_files $uri $uri/ /index.php?$query_string;
              }

              location ~ \.php$ {
                  fastcgi_pass app:9000;
                  fastcgi_index index.php;
                  fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
                  include fastcgi_params;
              }
          }
          EOL

          # Crear .env de producciÃ³n
          cat > .env <<'EOL'
          APP_NAME=Bike_Maintenance
          APP_ENV=production
          APP_KEY=${APP_KEY}
          APP_DEBUG=false
          APP_URL=${APP_URL}
          APP_LOCALE=es
          APP_FALLBACK_LOCALE=es
          APP_FAKER_LOCALE=es_ES
          PHP_CLI_SERVER_WORKERS=4
          BCRYPT_ROUNDS=12
          DB_CONNECTION=mysql
          DB_HOST=mysql         # Nombre del servicio Docker
          DB_PORT=${DB_PORT}
          DB_DATABASE=${DB_DATABASE}
          DB_USERNAME=${DB_USERNAME} # Se expande correctamente
          DB_PASSWORD=${DB_PASSWORD} # Se expande correctamente
          SESSION_DRIVER=database
          CACHE_STORE=database
          GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
          GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}
          GOOGLE_REDIRECT=${APP_URL}/oauth/google/callback
          EOL

          # Detener y levantar contenedores
          docker compose down || true
          docker compose up -d --build

          # â³ ESPERAR HASTA QUE MYSQL ESTÃ‰ DISPONIBLE â³
          echo "Esperando a que la base de datos estÃ© lista..."
          # Utilizamos el contenedor 'app' para ejecutar el script de espera.
          # Este script intenta conectarse al puerto 3306 del host 'mysql' hasta que tiene Ã©xito.
          docker compose exec -T app sh -c '
            max_retries=15; 
            retry_count=0;
            while ! nc -z mysql 3306 && [ $retry_count -lt $max_retries ]; do 
              echo "MySQL no estÃ¡ disponible aÃºn. Esperando 2 segundos..."; 
              sleep 2; 
              retry_count=$((retry_count + 1));
            done
            if [ $retry_count -eq $max_retries ]; then
              echo "Error: MySQL no iniciÃ³ a tiempo."
              exit 1
            fi
            echo "MySQL estÃ¡ listo. Continuar con las migraciones."
          '
          
          # ðŸ”‘ PASO CLAVE 1: CORREGIR PERMISOS COMO ROOT
          docker compose exec -T --user root app chmod -R 777 storage bootstrap/cache

          # ðŸ”‘ PASO CLAVE 2: Ejecutar comandos de Laravel (Como www-data)
          docker compose exec -T app php artisan migrate --force
          docker compose exec -T app php artisan cache:clear
          docker compose exec -T app php artisan config:cache
          docker compose exec -T app php artisan route:cache
          docker compose exec -T app php artisan view:cache
          docker compose exec -T app php artisan event:cache